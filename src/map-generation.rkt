#lang racket
(require noise thing "point.rkt" "tiles.rkt" "items.rkt" "entities.rkt" 2htdp/image)
(provide get-tile get-npcs update-npcs for-tile)
(struct level-definition (tile-gen npcs items))
(define levels (make-hasheq))
(define current-depth (make-parameter 0))
; Generate a new level if one does not exist
(define (get-level depth)
  (unless (hash-has-key? levels depth)
    (define level (make-hash))
    (hash-set! level 'seed (random))
    (hash-set! level 'npcs '())
    (hash-set! level 'gen (level-definition surface bunnies-and-goblins base-items))
    (hash-set! levels depth level))
  (hash-ref levels depth))

(define (get-tile x y)
  (define current-level (get-level (current-depth)))
  (define seed (hash-ref current-level 'seed))

  ; If the tile doesn't already exist, generate it
  (unless (hash-has-key? current-level (pt x y))
    ; Get the new tile
    ; Copy the tile here so that they don't share state
    (define new-tile
      (let ([base-tile ((level-definition-tile-gen (hash-ref current-level 'gen)) seed x y)])
        (make-thing base-tile)))
    
    (when (thing-get new-tile 'walkable)
      (define new-npc ((level-definition-npcs (hash-ref current-level 'gen)) seed x y))
      (when (and (not (void? new-npc)) new-npc)
        (let ([new-npc (make-thing new-npc [location (pt x y)])])
          (hash-set! current-level 'npcs (cons new-npc (hash-ref current-level 'npcs))))))
    ; (Potentially) generate a new item for that tile
    ; Do not generate an item if there already is one (generated by the tile generation routine)
    (when (empty? (thing-get new-tile 'items '()))
      (define new-item ((level-definition-items (hash-ref current-level 'gen)) seed x y))
      (when (and (not (void? new-item)) (thing-get new-tile 'walkable))
        (let ([new-item (make-thing new-item)])
          (thing-set! new-tile 'items (cons new-item (thing-get new-tile 'items))))))
    (hash-set! current-level (pt x y) new-tile))
  

  ; Return the tile (newly generated or not)
  (hash-ref current-level (pt x y)))

; The surface level with grass, water, and trees
(define (surface seed x y)
  ;                               snowy-level sea-level beach-level forest-level size freq redistribution
  ; (create-3d-simplex-with-water 6             .5           .6          1.2     100   3       4))
  (define sea-level .3)
  (define coast-level .5)
  (define beach-level 1)
  (define forest-level 6)
  (define jungle-level 3)
  (define desert-level 4)
  (define arctic-level 5)
  (define mountain-level 10)
  (define size 100)
  (define redistribution 6)
  (define freq 3)
  (define (get-elevation x y)
    (expt (abs (- 1
                  (+ (simplex (* freq (/ x size)) (* freq (/ y size)) seed)
                     (* 0.5 (simplex (* (* 2 freq) (/ x size))(* (* 2 freq) (/ y size)) seed))
                     (* 0.25 (simplex (* (* 4 freq) (/ x size))(* (* 2 freq) (/ y size)) seed)))
                  )) redistribution))
  (define e (get-elevation x y))
  (define water? (<= e sea-level))
  (define coast? (<= e coast-level))
  (define beach? (<= e beach-level))
  (define forest? (<= e forest-level))
  (define jungle? (<= e jungle-level))
  (define desert? (<= e desert-level))
  (define arctic? (<= e arctic-level))
  (define mountain? (<= e mountain-level))
  (define (create-grass)
    (let ([r (random 100)])
      (cond
        [(>= 5 r) (make-thing flower1)]
        [(>= 10 r) (make-thing flower2)]
        [(>= 15 r) (make-thing flower3)]
        [else (make-thing grass)])))
  
  (cond
    [water? (make-thing water)]
    [coast? (make-thing shallow-water)]
    [beach? (make-thing sand)]
    [forest? (if (>= 5 (random 100))
                 (make-thing forest-tree)
                 (create-grass))]
    [mountain? (make-thing mountain)]
    [else    (make-thing mountain-peak)]))

(define (nothing seed x y) #f)

; Loop over all generated tiles on the current level to update them
; f : x y tile -> void
(define (for-tile f)
  (for ([(pt tile) (in-hash (get-level (current-depth)))]
        #:when (pt? pt))
    (f (pt-x pt) (pt-y pt) tile)))

; Ascend or descend to a (potentially) new level
(define (ascend) (current-depth (+ (current-depth) 1)))
(define (descend) (current-depth (- (current-depth) 1)))

; Get the NPCs on the current level
(define (get-npcs)
  (hash-ref (get-level (current-depth)) 'npcs))

; Update npcs
(define (update-npcs world)
  (define current-level (get-level (current-depth)))
  (define npcs (hash-ref current-level 'npcs))
  
  ; Allow each to move
  (for ([npc (in-list npcs)])
    (thing-call npc 'act npc world))
  
  ; Check for (and remove) any dead npcs
  (hash-set! current-level 'npcs
             (filter 
              (lambda (npc)
                (when (<= (thing-get npc 'health) 0)
                  (send world log-message (format "~a has died" (thing-get npc 'name))))
                (> (thing-get npc 'health) 0))
              npcs)))

; Look up a thing from a vector by 'name
(define (lookup vec name)
  (let/ec return
    (for ([thing vec]
          #:when (equal? name (thing-get thing 'name #f)))
      (return thing))
    (return #f)))

(define *entities*
  (vector
   (make-thing fleeing-enemy
               [name "rat"]
               [character "r"]
               [color "gray"])

   (make-thing fleeing-enemy
               [name "bunny"]
               [character "b"]
               [color "lightblue"])
   
   (make-thing seeking-enemy
               [name "minotaur"]
               [character "M"]
               [color "brown"])  
   
   (make-thing seeking-enemy
               [name "goblin"]
               [character "g"]
               [color "orange"]
               [attack 15]
               [defense 5])))

; Enemy Generation routines
(define (bunnies-and-goblins seed x y)
  (when (zero? (random 100))
    (if (zero? (random 4))
        (lookup *entities* "goblin")
        (if (zero? (random 4))
            (lookup *entities* "bunny")
            (lookup *entities* "rat")))))

; Item Generation routines
(define (base-items seed x y)
  (when (zero? (random 500))
    (case (random 4)
      [(0) (lookup *gems* "emerald")]
      [(1) (lookup *gems* "ruby")]
      [(2) (lookup *gems* "sapphire")]
      [(3) (lookup *gems* "diamond")])))
        

;;; code for rendering sample maps

(define (real->natural n)
  (define (helper n acc)
    (cond
      [(>= acc n) acc]
      [(= acc 255) 255]
      [else (helper n (add1 acc))]))
  (helper n 0))

(define (render-surface size)
  (define TILE_SIZE 5)
  (define (draw-char c x y fg bg canvas)
    (let ([char (overlay
                 (text/font c TILE_SIZE fg "Menlo" 'script 'normal 'normal #f)
                 (rectangle TILE_SIZE TILE_SIZE "solid" (color 14 58 57)))])
      (place-image/align char (* x TILE_SIZE) (* y TILE_SIZE) 'left 'top canvas)))
  (define img (rectangle size size "solid" (color 14 58 57)))
  (for* ([x (in-range size)]
         [y (in-range size)])
    (define tile (get-tile x y))
    (set! img (draw-char (thing-get tile 'character) x y (thing-get tile 'color) "transparent" img)))
  img)

(define (render-surface2 size)
  (define TILE_SIZE 1)
  (define img (rectangle size size "solid" (color 14 58 57)))
  (for* ([x (in-range size)]
         [y (in-range size)])
    (define tile (get-tile x y))
    (set! img
          (place-image/align
           (text/font (thing-get tile 'character) TILE_SIZE (thing-get tile 'color) "Menlo" 'script 'normal 'normal #f)
           x y 'left 'top img)))
  img)

